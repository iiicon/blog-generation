---
title: 前端工程化实践笔记
date: 2020-08-18 11:17:36
categories: 前端工程化
tags: [scaffold, 笔记]
---

## 什么是浏览器的热更新

### Auto Compile 保存后自动编译

配置 watch:true 实现代码 auto compile

### live reload 自动刷新浏览器

为了每次代码修改页面都能自动刷新而无需手动点击，我们需要一种通讯机制来连接浏览器中的预览页面与本地监控代码变更的进程

官方的 devServer 通过 websocket 链接，就可以使打开的网页和本地服务间建立持久化的通信。当源代码发生变更时，我们就可以通过 Socket 通知到网页端，网页端在接到通知后会自动触发页面刷新。

### Hot Module Replacement 模块热替换

为了解决页面刷新导致的状态丢失问题，webpack 提出了模块热替换的概念，完整的 HMR 功能主要包含了三方面的技术：

watch 示例中体现的，对本地源代码文件内容变更的监控。

instant reload 示例中体现的，浏览器网页端与本地服务器端的 Websocket 通信。

hmr 示例中体现的，也即是最核心的，模块解析与替换功能。

![hmr.png](https://i.loli.net/2020/08/19/WVbzCnZMirKQL3B.png)

也就是说在这三种技术中，我们可以基于 Node.js 中提供的文件模块 fs.watch 来实现对文件和文件夹的监控，同样也可以使用 sockjs-node 或 socket.io 来实现 Websocket 的通信。

### webpack 中的打包流程

#### 术语

- module：指在模块化编程中我们把应用程序分割成的独立功能的代码模块。

- chunk：指模块间按照引用关系组合成的代码块，一个 chunk 中可以包含多个 module 。

- chunk group：指通过配置入口点（entry point）区分的块组，一个 chunk group 中可包含一到多个 chunk 。

- bundling：webpack 打包的过程。

- asset/bundle：打包产物。

#### 打包

1. 一切源代码文件均可通过各种 Loader 转换为 JS 模块 （module），模块之间可以互相引用。
2. webpack 通过入口点（entry point）递归处理各模块引用关系，最后输出为一个或多个产物包 js(bundle) 文件。
3. 每一个入口点都是一个块组（chunk group），在不考虑分包的情况下，一个 chunk group 中只有一个 chunk，该 chunk 包含递归分析后的所有模块。每一个 chunk 都有对应的一个打包后的输出文件（asset/bundle）。

在上面的 hmr 示例中，从 entry 中的 './src/index1.js' 到打包产物的 dist/main.js ，以模块的角度而言，其基本流程是：

1. 唯一 entry 创建一个块组（chunk group）， name 为 main ，包含了 ./src/index1.js 这一个模块。
2. 在解析器中处理 ./src/index1.js 模块的代码，找到了其依赖的 './style.css' ，找到匹配的 loader: css-loader 和 style-loader 。
3. 首先通过 css-loader 处理，将 css-loader/dist/cjs.js!./src/style.css 模块（即把 CSS 文件内容转化为 js 可执行代码的模块，这里简称为 Content 模块）和 css-loader/dist/runtime/api.js 模块打入 chunk 中。
4. 然后通过 style-loader 处理，将 style-loader/dist/runtime/injectStylesIntoStyleTag.js 模块 （我们这里简称为 API 模块），以及处理后的 .src/style.css 模块（作用是运行时中通过 API 模块将 Content 模块内容注入 Style 标签）导入 chunk 中。
5. 依次类推，直到将所有依赖的模块均打入到 chunk 中，最后输出名为 main.js 的产物（我们称为 Asset 或 Bundle）。

style-loader 中的热替换代码

```js
var cssContentPath = "./node_modules/css-loader/dist/cjs.js!./src/style.css"
var api = __webpack_require__("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(cssContentPath);
...
var update = api(content, options);
...
module.hot.accept(
  cssContentPath,
  function(){
    content = __webpack_require__(cssContentPath);
    ...
    update(content);
  }
)
module.hot.dispose(function() {
  update();
});
```

### HotModuleReplacementPlugin 模块热替换插件

对指定的 js 文件实现热替换

```js
//./text.js
export const text = "Hello World";
//./index2.js
import { text } from "./text.js";
const div = document.createElement("div");
document.body.appendChild(div);
function render() {
  div.innerHTML = text;
}
render();
if (module.hot) {
  module.hot.accept("./text.js", function () {
    render();
  });
}
```

从上面的例子中我们可以看到，热替换的实现，既依赖 webpack 核心代码中 HotModuleReplacementPlugin 所提供的相关 API，也依赖在具体模块的加载器中实现相应 API 的更新替换逻辑
